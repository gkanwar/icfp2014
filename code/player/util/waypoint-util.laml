;;;; -*- mode: scheme -*-
;;;; Utilities for getting directions to waypoints using BFS to find the
;;;; shortest route. Since paths are reverse-order, BFS from the target TO
;;;; your location, then flip directions.

;;; Path is defined as (current loc, directions). Direction is a reverse list.
;;; Paths are forbidden from reversing direction.
(define make-path
  (lambda (loc dirs)
    (cons loc dirs)))
(define get-path-loc
  (lambda (path)
    (car path)))
(define get-path-dirs
  (lambda (path)
    (cdr path)))
(define extend-path
  (lambda (path dir)
    (make-path (get-dir-loc dir (get-path-loc path))
               (cons dir (get-path-dirs path)))))

;;; Flip the directions on each path
(define flip-path-dirs
  (lambda (path)
    (make-path
     (get-path-loc path)
     (map get-opposing-dir (get-path-dirs path)))))

;; Frontier is a list of paths
(define has-loc?
  (lambda (loc frontier)
    (if (null? frontier)
        false
        (if (loc=? (get-path-loc (car frontier))
                   loc)
            true
            (has-loc? loc (cdr frontier))))))

;; Guard this call with (has-loc?)
(define get-path-with-loc
  (lambda (loc frontier)
    (if (null? frontier)
        nil
        (if (loc=? (get-path-loc (car frontier))
                   loc)
            (car frontier)
            (get-path-with-loc loc (cdr frontier))))))

(define bfs-helper
  (lambda (world-map target frontier)
    ;; world-map - map of the world
    ;; seen-map - which squares we've visited
    ;; target - current target (row, col) pair
    ;; frontier - list of paths
    ;; Returns best path out from target. BFS *to* your start and
    ;; use flip-path-dirs to get a path from start to end.
    (begin
      (if (has-loc? target frontier)
          (get-path-with-loc target frontier)
          (if (null? frontier)
              (begin
                ;; This should never happen!
                (dbug 666)
                ;; Cause Lambda Man to go right, thinking he's progressing towards
                ;; the target...
                (make-path target (list left)))
              (begin
                (define expand-path
                  (lambda (new-frontier next-path)
                    (begin
                      (define prev-loc
                        (get-path-loc next-path))
                      (define prev-dirs (get-path-dirs next-path))
                      (define valid-dirs
                        (filter
                         (lambda (dir)
                           (and (not (is-wall world-map (get-dir-loc dir prev-loc)))
                                ;; null means no previous direction, so any dir is fine
                                ;; Need to use sc-or here so that we don't try to evaluate
                                ;; the car of a nil list.
                                (sc-or (lambda (THUNK)
                                         (null? prev-dirs))
                                       (lambda (THUNK)
                                         (not (opposing-dir? dir (car prev-dirs)))))))
                         all-dirs))
                      (list-extend
                       (map
                        (lambda (dir)
                          (extend-path next-path dir))
                        valid-dirs)
                       new-frontier))))
                (define new-frontier
                  (fold-left expand-path nil frontier))
                (bfs-helper world-map target new-frontier)))))))

(define bfs
  (lambda (world-map start end)
    (begin
      (define reverse-path
        (bfs-helper world-map start (list (make-path end nil))))
      (flip-path-dirs reverse-path))))

;;; Waypoint functions
(define compute-waypoint-path
  (lambda (world-map loc waypoint)
    (get-path-dirs (bfs world-map loc waypoint))))
